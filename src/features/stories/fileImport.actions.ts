import type { Telegraf } from "telegraf";
import type { MyContext } from "../../shared/types.js";
import { Markup } from "telegraf";
import { bufferToText, parseStoryFromText } from "./docText.js";
import {
  getOrCreateDraft,
  setField,
  setEndingTitle,
  setEndingText,
  resetPending,
} from "./draft.service.js";
import { renderAddStoryTextScreen } from "../../app/ui/screens.addStoryText.js";
import { isAdmin } from "../../shared/utils.js";
import {
  getPendingImport,
  setPendingImport,
  clearPendingImport,
} from "./import.state.js";
import { getLastMessageId } from "../../app/middlewares/singleMessage.js";
import { logTelegramError } from "../../shared/logger.js";
import { safeEdit } from "../../app/ui/respond.js";
import { logError } from "../../shared/logger.js";

function html(s = "") {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

async function updateMenu(ctx: MyContext, text: string, inline?: any) {
  try { await safeEdit(ctx, text, inline, "HTML") } catch (e) { logTelegramError("fileImport.updateMenu.safeEdit", e) }
}

const HELP = () => `–ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–∞–π–ª –≤ –æ–¥–Ω–æ–º –∏–∑ —Ñ–æ—Ä–º–∞—Ç–æ–≤: <b>DOCX / RTF / TXT</b>.

<b>–ü–∞—Ç—Ç–µ—Ä–Ω —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ:</b>
<pre><code>TITLE: –ú–æ–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
INTRO:
–¢–µ–∫—Å—Ç –Ω–∞—á–∞–ª–∞ –∏—Å—Ç–æ—Ä–∏–∏...

ENDING1_TITLE: –ù–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è
ENDING1_TEXT:
–¢–µ–∫—Å—Ç –ø–µ—Ä–≤–æ–≥–æ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è...

ENDING2_TITLE: ...
ENDING2_TEXT:
...

ENDING3_TITLE: ...
ENDING3_TEXT:
...</code></pre>

–ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å 1‚Äì3 –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è. –†–µ–≥–∏—Å—Ç—Ä –∏ —Ä—É—Å—Å–∫–∏–µ —Ç–µ–≥–∏ —Ç–æ–∂–µ –ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è (–Ω–∞–ø—Ä–∏–º–µ—Ä:
<code>–ù–ê–ó–í–ê–ù–ò–ï:</code>, <code>–ù–ê–ß–ê–õ–û:</code>, <code>–ü–†–û–î–û–õ–ñ–ï–ù–ò–ï1_–ù–ê–ó–í–ê–ù–ò–ï:</code>, <code>–ü–†–û–î–û–õ–ñ–ï–ù–ò–ï1_–¢–ï–ö–°–¢:</code>).`;

export function registerFileImportActions(bot: Telegraf<MyContext>) {
  bot.action("admin:import_file", async (ctx) => {
    if (!ctx.state.user || !isAdmin(ctx.state.user)) {
      await ctx.answerCbQuery();
      return updateMenu(
        ctx,
        "–î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞.",
        Markup.inlineKeyboard([[Markup.button.callback("‚Ü©Ô∏é –ù–∞–∑–∞–¥", "main")]])
      );
    }
    await ctx.answerCbQuery();
    setPendingImport(ctx.state.user.tgId);
    await resetPending(ctx.state.user.tgId);

    return updateMenu(
      ctx,
      `üì® –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ –¥–ª—è –∏–º–ø–æ—Ä—Ç–∞\n\n${HELP()}`,
      Markup.inlineKeyboard([
        [Markup.button.callback("‚Ü©Ô∏é –í –∞–¥–º–∏–Ω-–º–µ–Ω—é", "admin")],
      ])
    );
  });

  bot.on("document", async (ctx, next) => {
    const u = ctx.state.user;
    if (!u || !isAdmin(u)) return next();
    if (!getPendingImport(u.tgId)) return next();

    const msg: any = ctx.message;
    const doc: any = msg?.document;
    if (!doc) return next();

    const mime = String(doc.mime_type || "");
    const fileId = String(doc.file_id);
    const fileName = String(doc.file_name || "");
    const lower = fileName.toLowerCase();

    const isDocx =
      mime.includes("wordprocessingml.document") || lower.endsWith(".docx");
    const isRtf = mime.includes("rtf") || lower.endsWith(".rtf");
    const isTxt = mime.startsWith("text/") || lower.endsWith(".txt");

    const chatId = ctx.chat?.id;
    const msgId = msg?.message_id;
    const safeDeleteUserMessage = async () => {
      if (!chatId || !msgId) return;
      try {
        await ctx.telegram.deleteMessage(chatId, msgId);
      } catch (e) { logTelegramError("fileImport.deleteUserMessage", e, { chatId, msgId }) }
    };

    if (!(isDocx || isRtf || isTxt)) {
      await safeDeleteUserMessage();
      return updateMenu(
        ctx,
        `‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç: <code>${html(
          mime || fileName
        )}</code>\n\n${HELP()}`,
        Markup.inlineKeyboard([
          [Markup.button.callback("‚Ü©Ô∏é –í –∞–¥–º–∏–Ω-–º–µ–Ω—é", "admin")],
        ])
      );
    }

    try {
      const link = await ctx.telegram.getFileLink(fileId);
      const res = await fetch(link.href);
      const buf = Buffer.from(await res.arrayBuffer());

      const plain = await bufferToText(buf, mime, fileName);
      const parsed = parseStoryFromText(plain);

      if (!parsed.title || !parsed.intro) {
        await safeDeleteUserMessage();
        return updateMenu(
          ctx,
          `‚ùå –í —Ñ–∞–π–ª–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Å–µ–∫—Ü–∏–∏ <code>TITLE</code> –∏/–∏–ª–∏ <code>INTRO</code>.\n\n${HELP()}`,
          Markup.inlineKeyboard([
            [Markup.button.callback("‚Ü©Ô∏é –í –∞–¥–º–∏–Ω-–º–µ–Ω—é", "admin")],
          ])
        );
      }

      const d = await getOrCreateDraft(u.tgId);
      await setField(u.tgId, "title", parsed.title.trim());
      await setField(u.tgId, "intro", parsed.intro.trim());

      d.endings.splice(0, d.endings.length);
      const ends = (parsed.endings || []).slice(0, 3);
      for (let i = 0; i < ends.length; i++) {
        if (ends[i].title) await setEndingTitle(u.tgId, i, ends[i].title!);
        if (ends[i].text) await setEndingText(u.tgId, i, ends[i].text!);
      }

      clearPendingImport(u.tgId);
      await safeDeleteUserMessage();

      const payload = await renderAddStoryTextScreen(ctx);
      return updateMenu(
        ctx,
        `‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω –∏ –∑–∞–≥—Ä—É–∂–µ–Ω –≤ —á–µ—Ä–Ω–æ–≤–∏–∫.\n\n${payload.text}`,
        payload.inline
      );
    } catch (e) {
      logError("fileImport.processDocument", e, { fileId, fileName, mime })
      await safeDeleteUserMessage();
      return updateMenu(
        ctx,
        `‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ç—Ç–µ—Ä–Ω –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.\n\n${HELP()}`,
        Markup.inlineKeyboard([
          [Markup.button.callback("‚Ü©Ô∏é –í –∞–¥–º–∏–Ω-–º–µ–Ω—é", "admin")],
        ])
      );
    }
  });
}
